{"mappings":"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","sources":["./node_modules/@parcel/scope-hoisting/lib/helpers.js","./packages/react/roving-focus/src/RovingFocusGroup.tsx"],"sourcesContent":["function $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\n\nfunction $parcel$defineInteropFlag(a) {\n  Object.defineProperty(a, '__esModule', {value: true});\n}\n\nfunction $parcel$reexport(e, n, v) {\n  Object.defineProperty(e, n, {get: v, enumerable: true});\n}\n\nfunction $parcel$exportWildcard(dest, source) {\n  Object.keys(source).forEach(function(key) {\n    if (key === 'default' || key === '__esModule') {\n      return;\n    }\n\n    Object.defineProperty(dest, key, {\n      enumerable: true,\n      get: function get() {\n        return source[key];\n      },\n    });\n  });\n\n  return dest;\n}\n\nfunction $parcel$missingModule(name) {\n  var err = new Error(\"Cannot find module '\" + name + \"'\");\n  err.code = 'MODULE_NOT_FOUND';\n  throw err;\n}\n\nvar $parcel$global =\n  typeof globalThis !== 'undefined'\n    ? globalThis\n    : typeof self !== 'undefined'\n    ? self\n    : typeof window !== 'undefined'\n    ? window\n    : typeof global !== 'undefined'\n    ? global\n    : {};\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useId } from '@radix-ui/react-id';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\n\nimport type * as Radix from '@radix-ui/react-primitive';\nimport type { Scope } from '@radix-ui/react-context';\n\nconst ENTRY_FOCUS = 'rovingFocusGroup.onEntryFocus';\nconst EVENT_OPTIONS = { bubbles: false, cancelable: true };\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'RovingFocusGroup';\n\ntype ItemData = { id: string; focusable: boolean; active: boolean };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  HTMLSpanElement,\n  ItemData\n>(GROUP_NAME);\n\ntype ScopedProps<P> = P & { __scopeRovingFocusGroup?: Scope };\nconst [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(\n  GROUP_NAME,\n  [createCollectionScope]\n);\n\ntype Orientation = React.AriaAttributes['aria-orientation'];\ntype Direction = 'ltr' | 'rtl';\n\ninterface RovingFocusGroupOptions {\n  /**\n   * The orientation of the group.\n   * Mainly so arrow navigation is done accordingly (left & right vs. up & down)\n   */\n  orientation?: Orientation;\n  /**\n   * The direction of navigation between items.\n   * @defaultValue ltr\n   */\n  dir?: Direction;\n  /**\n   * Whether keyboard navigation should loop around\n   * @defaultValue false\n   */\n  loop?: boolean;\n}\n\ntype RovingContextValue = RovingFocusGroupOptions & {\n  currentTabStopId: string | null;\n  onItemFocus(tabStopId: string): void;\n  onItemShiftTab(): void;\n};\n\nconst [RovingFocusProvider, useRovingFocusContext] =\n  createRovingFocusGroupContext<RovingContextValue>(GROUP_NAME);\n\ntype RovingFocusGroupElement = RovingFocusGroupImplElement;\ninterface RovingFocusGroupProps extends RovingFocusGroupImplProps {}\n\nconst RovingFocusGroup = React.forwardRef<RovingFocusGroupElement, RovingFocusGroupProps>(\n  (props: ScopedProps<RovingFocusGroupProps>, forwardedRef) => {\n    return (\n      <Collection.Provider scope={props.__scopeRovingFocusGroup}>\n        <Collection.Slot scope={props.__scopeRovingFocusGroup}>\n          <RovingFocusGroupImpl {...props} ref={forwardedRef} />\n        </Collection.Slot>\n      </Collection.Provider>\n    );\n  }\n);\n\nRovingFocusGroup.displayName = GROUP_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype RovingFocusGroupImplElement = React.ElementRef<typeof Primitive.div>;\ntype PrimitiveDivProps = Radix.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface RovingFocusGroupImplProps\n  extends Omit<PrimitiveDivProps, 'dir'>,\n    RovingFocusGroupOptions {\n  currentTabStopId?: string | null;\n  defaultCurrentTabStopId?: string;\n  onCurrentTabStopIdChange?: (tabStopId: string | null) => void;\n  onEntryFocus?: (event: Event) => void;\n}\n\nconst RovingFocusGroupImpl = React.forwardRef<\n  RovingFocusGroupImplElement,\n  RovingFocusGroupImplProps\n>((props: ScopedProps<RovingFocusGroupImplProps>, forwardedRef) => {\n  const {\n    __scopeRovingFocusGroup,\n    orientation,\n    dir = 'ltr',\n    loop = false,\n    currentTabStopId: currentTabStopIdProp,\n    defaultCurrentTabStopId,\n    onCurrentTabStopIdChange,\n    onEntryFocus,\n    ...groupProps\n  } = props;\n  const ref = React.useRef<RovingFocusGroupImplElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n  const [currentTabStopId = null, setCurrentTabStopId] = useControllableState({\n    prop: currentTabStopIdProp,\n    defaultProp: defaultCurrentTabStopId,\n    onChange: onCurrentTabStopIdChange,\n  });\n  const [isTabbingBackOut, setIsTabbingBackOut] = React.useState(false);\n  const handleEntryFocus = useCallbackRef(onEntryFocus);\n  const getItems = useCollection(__scopeRovingFocusGroup);\n  const isClickFocusRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);\n      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);\n    }\n  }, [handleEntryFocus]);\n\n  return (\n    <RovingFocusProvider\n      scope={__scopeRovingFocusGroup}\n      orientation={orientation}\n      dir={dir}\n      loop={loop}\n      currentTabStopId={currentTabStopId}\n      onItemFocus={React.useCallback(\n        (tabStopId) => setCurrentTabStopId(tabStopId),\n        [setCurrentTabStopId]\n      )}\n      onItemShiftTab={React.useCallback(() => setIsTabbingBackOut(true), [])}\n    >\n      <Primitive.div\n        tabIndex={isTabbingBackOut ? -1 : 0}\n        data-orientation={orientation}\n        {...groupProps}\n        ref={composedRefs}\n        style={{ outline: 'none', ...props.style }}\n        onMouseDown={composeEventHandlers(props.onMouseDown, () => {\n          isClickFocusRef.current = true;\n        })}\n        onFocus={composeEventHandlers(props.onFocus, (event) => {\n          // We normally wouldn't need this check, because we already check\n          // that the focus is on the current target and not bubbling to it.\n          // We do this because Safari doesn't focus buttons when clicked, and\n          // instead, the wrapper will get focused and not through a bubbling event.\n          const isKeyboardFocus = !isClickFocusRef.current;\n\n          if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {\n            const entryFocusEvent = new Event(ENTRY_FOCUS, EVENT_OPTIONS);\n            event.currentTarget.dispatchEvent(entryFocusEvent);\n\n            if (!entryFocusEvent.defaultPrevented) {\n              const items = getItems().filter((item) => item.focusable);\n              const activeItem = items.find((item) => item.active);\n              const currentItem = items.find((item) => item.id === currentTabStopId);\n              const candidateItems = [activeItem, currentItem, ...items].filter(\n                Boolean\n              ) as typeof items;\n              const candidateNodes = candidateItems.map((item) => item.ref.current!);\n              focusFirst(candidateNodes);\n            }\n          }\n\n          isClickFocusRef.current = false;\n        })}\n        onBlur={composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))}\n      />\n    </RovingFocusProvider>\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * RovingFocusGroupItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'RovingFocusGroupItem';\n\ntype RovingFocusItemElement = React.ElementRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = Radix.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface RovingFocusItemProps extends PrimitiveSpanProps {\n  focusable?: boolean;\n  active?: boolean;\n}\n\nconst RovingFocusGroupItem = React.forwardRef<RovingFocusItemElement, RovingFocusItemProps>(\n  (props: ScopedProps<RovingFocusItemProps>, forwardedRef) => {\n    const { __scopeRovingFocusGroup, focusable = true, active = false, ...itemProps } = props;\n    const id = useId();\n    const context = useRovingFocusContext(ITEM_NAME, __scopeRovingFocusGroup);\n    const isCurrentTabStop = context.currentTabStopId === id;\n    const getItems = useCollection(__scopeRovingFocusGroup);\n\n    return (\n      <Collection.ItemSlot\n        scope={__scopeRovingFocusGroup}\n        id={id}\n        focusable={focusable}\n        active={active}\n      >\n        <Primitive.span\n          tabIndex={isCurrentTabStop ? 0 : -1}\n          data-orientation={context.orientation}\n          {...itemProps}\n          ref={forwardedRef}\n          onMouseDown={composeEventHandlers(props.onMouseDown, (event) => {\n            // We prevent focusing non-focusable items on `mousedown`.\n            // Even though the item has tabIndex={-1}, that only means take it out of the tab order.\n            if (!focusable) event.preventDefault();\n            // Safari doesn't focus a button when clicked so we run our logic on mousedown also\n            else context.onItemFocus(id);\n          })}\n          onFocus={composeEventHandlers(props.onFocus, () => context.onItemFocus(id))}\n          onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n            if (event.key === 'Tab' && event.shiftKey) {\n              context.onItemShiftTab();\n              return;\n            }\n\n            if (event.target !== event.currentTarget) return;\n\n            const focusIntent = getFocusIntent(event, context.orientation, context.dir);\n\n            if (focusIntent !== undefined) {\n              event.preventDefault();\n              const items = getItems().filter((item) => item.focusable);\n              let candidateNodes = items.map((item) => item.ref.current!);\n\n              if (focusIntent === 'last') candidateNodes.reverse();\n              else if (focusIntent === 'prev' || focusIntent === 'next') {\n                if (focusIntent === 'prev') candidateNodes.reverse();\n                const currentIndex = candidateNodes.indexOf(event.currentTarget);\n                candidateNodes = context.loop\n                  ? wrapArray(candidateNodes, currentIndex + 1)\n                  : candidateNodes.slice(currentIndex + 1);\n              }\n\n              /**\n               * Imperative focus during keydown is risky so we prevent React's batching updates\n               * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n               */\n              setTimeout(() => focusFirst(candidateNodes));\n            }\n          })}\n        />\n      </Collection.ItemSlot>\n    );\n  }\n);\n\nRovingFocusGroupItem.displayName = ITEM_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\n// prettier-ignore\nconst MAP_KEY_TO_FOCUS_INTENT: Record<string, FocusIntent> = {\n  ArrowLeft: 'prev', ArrowUp: 'prev',\n  ArrowRight: 'next', ArrowDown: 'next',\n  PageUp: 'first', Home: 'first',\n  PageDown: 'last', End: 'last',\n};\n\nfunction getDirectionAwareKey(key: string, dir?: Direction) {\n  if (dir !== 'rtl') return key;\n  return key === 'ArrowLeft' ? 'ArrowRight' : key === 'ArrowRight' ? 'ArrowLeft' : key;\n}\n\ntype FocusIntent = 'first' | 'last' | 'prev' | 'next';\n\nfunction getFocusIntent(event: React.KeyboardEvent, orientation?: Orientation, dir?: Direction) {\n  const key = getDirectionAwareKey(event.key, dir);\n  if (orientation === 'vertical' && ['ArrowLeft', 'ArrowRight'].includes(key)) return undefined;\n  if (orientation === 'horizontal' && ['ArrowUp', 'ArrowDown'].includes(key)) return undefined;\n  return MAP_KEY_TO_FOCUS_INTENT[key];\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n  for (const candidate of candidates) {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n    candidate.focus();\n    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n  }\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map((_, index) => array[(startIndex + index) % array.length]);\n}\n\nconst Root = RovingFocusGroup;\nconst Item = RovingFocusGroupItem;\n\nexport {\n  createRovingFocusGroupScope,\n  //\n  RovingFocusGroup,\n  RovingFocusGroupItem,\n  //\n  Root,\n  Item,\n};\nexport type { RovingFocusGroupProps, RovingFocusItemProps };\n"],"names":["dest","source","a","Object","keys","forEach","key","defineProperty","enumerable","get","__esModule","default","EVENT_OPTIONS","bubbles","cancelable","Collection","useCollection","createCollectionScope","createCollection","createRovingFocusGroupContext","createRovingFocusGroupScope","createContextScope","RovingFocusProvider","useRovingFocusContext","RovingFocusGroup","React","forwardRef","props","forwardedRef","_react","createElement","$e775be37c80f9cb18a9ef43638f10ed0$var$Collection","Provider","scope","__scopeRovingFocusGroup","Slot","$e775be37c80f9cb18a9ef43638f10ed0$var$RovingFocusGroupImpl","_babelRuntimeHelpersExtends","ref","RovingFocusGroupImpl","orientation","dir","loop","currentTabStopId","currentTabStopIdProp","defaultCurrentTabStopId","onCurrentTabStopIdChange","onEntryFocus","groupProps","useRef","composedRefs","useComposedRefs","setCurrentTabStopId","useControllableState","prop","defaultProp","onChange","isTabbingBackOut","setIsTabbingBackOut","useState","handleEntryFocus","useCallbackRef","getItems","isClickFocusRef","useEffect","node","current","addEventListener","removeEventListener","$e775be37c80f9cb18a9ef43638f10ed0$var$RovingFocusProvider","onItemFocus","useCallback","tabStopId","onItemShiftTab","Primitive","div","tabIndex","style","outline","onMouseDown","composeEventHandlers","onFocus","event","isKeyboardFocus","target","currentTarget","entryFocusEvent","Event","dispatchEvent","defaultPrevented","items","filter","item","focusable","focusFirst","find","active","id","Boolean","map","onBlur","RovingFocusGroupItem","itemProps","useId","context","isCurrentTabStop","ItemSlot","span","preventDefault","onKeyDown","shiftKey","focusIntent","getDirectionAwareKey","includes","MAP_KEY_TO_FOCUS_INTENT","getFocusIntent","undefined","candidateNodes","reverse","currentIndex","indexOf","startIndex","array","_","index","length","slice","setTimeout","ArrowLeft","ArrowUp","ArrowRight","ArrowDown","PageUp","Home","PageDown","End","candidates","PREVIOUSLY_FOCUSED_ELEMENT","document","activeElement","candidate","focus","Root","Item"],"version":3,"file":"index.js.map"}